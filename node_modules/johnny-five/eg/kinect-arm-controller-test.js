"use strict";

var five, PVector, OpenNI, isTest;

five = require("../lib/johnny-five.js");
/**
 * Note:
 *
 * PVector is a slightly-ported version of
 * Processing.js's PVector.
 *
 */
PVector = require("./pvector.js").PVector;
/**
 * Note:
 *
 * To run this program you must first install
 * libusb and OpenNI... Good luck with that.
 *
 * Two sets of instructions are available:
 * - https://github.com/OpenNI/OpenNI
 * - https://code.google.com/p/simple-openni/wiki/Installation
 *
 * Then:
 *
 * npm install oppeni
 *
 * Learn more about node-openni here:
 * - https://github.com/pgte/node-openni
 *
 */
OpenNI = require("openni");


isTest = process.argv.length === 3 && process.argv[2] === "test";

if ( isTest ) {
  var assert = require("assert");
}

/**
 * Joint
 *
 * Construct Joint objects.
 *
 * @param {Object} initializer { [x, [y, [z]]] }
 */
function Joint( initializer ) {
  /**
   * joint {
   *   x, y, z
   * }
   */
  five.Fn.assign(
    this, Joint.DEFAULTS, initializer || {}
  );
}

Object.freeze(
  Joint.DEFAULTS = {
    x: 0, y: 0, z: 0
  }
);

if ( isTest ) {
  var a = { x: 1, y: 2, z: 3 };
  var b = new Joint(new Joint( a ));

  assert.deepEqual( a, b );
  assert.throws(function() {
    Joint.DEFAULTS.x = 10;
  });
}

/**
 * Skeleton
 *
 * Initialize a "collection" of Joint objects
 * as a cohesive data type
 *
 * @param {Object} initializer { joints = {} }
 */
function Skeleton( initializer ) {
  /**
   * skeleton {
   *   joints, kinect
   * }
   */
  five.Fn.assign(
    this, Skeleton.DEFAULTS, initializer || {}
  );

  // Initialize each declared Joint in Skeleton.Joints
  Skeleton.Joints.forEach(function( joint ) {
    this.joints[ joint ] = new Joint();
  }, this );
}

Object.freeze(
  Skeleton.DEFAULTS = {
    inFrame: false,
    joints: {}
  }
);

Skeleton.Joints = [
  "head",
  "neck",

  "torso",
  "waist",

  "left_shoulder",
  "left_elbow",
  "left_hand",

  "right_shoulder",
  "right_elbow",
  "right_hand",

  "left_hip",
  "left_knee",
  "left_foot",

  "right_hip",
  "right_knee",
  "right_foot"
];

Skeleton.Events = [
  "newuser",
  "lostuser",
  "posedetected",
  "calibrationstart",
  "calibrationsuccess",
  "calibrationfail"
];

var Skeletons  = [];


/**
 * Change
 *
 * Produces change "tracking" instances
 * to determine if a given value has changed
 * drastically enough
 */
function Change(margin) {
  this.last = 0;
  this.margin = margin || 0;
}

/**
 * isNoticeable
 *
 * Determine if a given value has changed
 * enough to be considered "noticeable".
 *
 * @param  {Number} value  [description]
 * @param  {Number} margin Optionally override the
 *                         change instance's margin
 *
 * @return {Boolean} returns true if value is different
 *                           enough from the last value
 *                           to be considered "noticeable"
 */
Change.prototype.isNoticeable = function(value, margin) {
  margin = margin || this.margin;

  if ( !Number.isFinite(value) ) {
    return false;
  }

  if ( (value > this.last + margin) || (value < this.last - margin) ) {
    this.last = value;
    return true;
  }
  return false;
};

/**
 * scale
 *
 * Scaling that provides rounding on
 * the scaled result value.
 *
 * @return {Number}
 */
function scale() {
  return Math.round(
    five.Fn.scale.apply(null, arguments)
  );
}

/**
 * angleOf
 *
 * Produce the angle of 2 vectors on a given axis.
 *
 * @param  {PVector} vec1
 * @param  {PVector} vec2
 * @param  {PVector} axis
 *
 * @return {Number} Radians converted to degrees
 */
function angleOf( vec1, vec2, axis ) {
  return PVector.degrees(
    PVector.between(
      PVector.sub( vec2, vec1 ), axis
    )
  );
}
